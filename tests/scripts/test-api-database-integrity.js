#!/usr/bin/env node
/**
 * OpenPenPal API‰∏éÊï∞ÊçÆÂ∫ìÂÆåÊï¥ÊÄßÊµãËØïËÑöÊú¨
 * 
 * ÂäüËÉΩÔºö
 * 1. ÊµãËØïÊâÄÊúâAPIÁ´ØÁÇπÁöÑÂèØÁî®ÊÄß
 * 2. È™åËØÅÊï∞ÊçÆÂ∫ìË°®ÁªìÊûÑÂíåÊï∞ÊçÆ‰∏ÄËá¥ÊÄß  
 * 3. ÊµãËØïË∑®ÊúçÂä°Êï∞ÊçÆ‰∫§‰∫í
 * 4. È™åËØÅ‰∏öÂä°ÈÄªËæëÂÆåÊï¥ÊÄß
 */

const fetch = globalThis.fetch;
const { execSync } = require('child_process');

// ÊµãËØïÈÖçÁΩÆ
const CONFIG = {
    backends: {
        main: 'http://localhost:8080'
        // Ê≥®ÈáäÊéâÊú™ËøêË°åÁöÑÊúçÂä°
        // gateway: 'http://localhost:8000', 
        // writeService: 'http://localhost:8001',
        // courierService: 'http://localhost:8002',
        // adminService: 'http://localhost:8003',
        // ocrService: 'http://localhost:8004'
    },
    frontend: 'http://localhost:3000',
    database: {
        host: 'localhost',
        port: 5432,
        database: 'openpenpal',
        user: 'rocalight'
    },
    testUser: {
        username: 'admin',
        password: 'admin123'
    }
};

class APIIntegrityTester {
    constructor() {
        this.results = {
            services: {},
            apis: {},
            database: {},
            integration: {},
            summary: {}
        };
        this.authToken = null;
        this.testStartTime = new Date();
    }

    async log(message, type = 'info') {
        const timestamp = new Date().toISOString();
        const prefix = {
            'error': '‚ùå',
            'success': '‚úÖ', 
            'warning': '‚ö†Ô∏è',
            'info': '‚ÑπÔ∏è',
            'test': 'üß™',
            'db': 'üóÑÔ∏è'
        }[type] || '‚ÑπÔ∏è';
        
        console.log(`${timestamp} ${prefix} ${message}`);
    }

    async test(name, testFn, category = 'general') {
        try {
            await this.log(`ÂºÄÂßãÊµãËØï: ${name}`, 'test');
            const startTime = Date.now();
            const result = await testFn();
            const duration = Date.now() - startTime;
            
            if (!this.results[category]) {
                this.results[category] = {};
            }
            
            this.results[category][name] = {
                success: true,
                result,
                duration,
                timestamp: new Date()
            };
            
            await this.log(`‚úì ${name} (${duration}ms)`, 'success');
            return result;
        } catch (error) {
            if (!this.results[category]) {
                this.results[category] = {};
            }
            
            this.results[category][name] = {
                success: false,
                error: error.message,
                duration: Date.now() - (this.testStartTime.getTime()),
                timestamp: new Date()
            };
            
            await this.log(`‚úó ${name}: ${error.message}`, 'error');
            return null;
        }
    }

    // ===== ÊúçÂä°ÂÅ•Â∫∑Ê£ÄÊü• =====
    async testServiceHealth() {
        await this.log('ÂºÄÂßãÊúçÂä°ÂÅ•Â∫∑Ê£ÄÊü•...', 'info');
        
        for (const [serviceName, url] of Object.entries(CONFIG.backends)) {
            await this.test(`${serviceName} ÂÅ•Â∫∑Ê£ÄÊü•`, async () => {
                const response = await fetch(`${url}/health`, {
                    method: 'GET',
                    timeout: 5000
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                return {
                    status: response.status,
                    healthy: data.status === 'healthy' || response.status === 200,
                    data
                };
            }, 'services');
        }
    }

    // ===== Áî®Êà∑ËÆ§ËØÅÊµãËØï =====
    async testAuthentication() {
        await this.log('ÂºÄÂßãËÆ§ËØÅÁ≥ªÁªüÊµãËØï...', 'info');
        
        // È¶ñÂÖàËé∑ÂèñCSRF token
        await this.test('Ëé∑ÂèñCSRF token', async () => {
            const response = await fetch(`${CONFIG.backends.main}/api/v1/auth/csrf`, {
                method: 'GET'
            });

            if (!response.ok) {
                throw new Error(`CSRF tokenËé∑ÂèñÂ§±Ë¥•: ${response.status}`);
            }

            const data = await response.json();
            this.csrfToken = data.data?.token;
            
            // Ëé∑Âèñcookie‰∏≠ÁöÑCSRF token
            const cookies = response.headers.get('set-cookie');
            if (cookies) {
                const csrfCookieMatch = cookies.match(/csrf-token=([^;]+)/);
                if (csrfCookieMatch) {
                    this.csrfCookie = csrfCookieMatch[1];
                }
            }
            
            return { token: this.csrfToken?.substring(0, 20) + '...' };
        }, 'apis');
        
        return await this.test('Áî®Êà∑ÁôªÂΩïËÆ§ËØÅ', async () => {
            const headers = {
                'Content-Type': 'application/json'
            };
            
            // Ê∑ªÂä†CSRF tokenÂà∞header
            if (this.csrfToken) {
                headers['X-CSRF-Token'] = this.csrfToken;
            }
            
            // Ê∑ªÂä†CSRF cookie
            if (this.csrfCookie) {
                headers['Cookie'] = `csrf-token=${this.csrfCookie}`;
            }

            const response = await fetch(`${CONFIG.backends.main}/api/v1/auth/login`, {
                method: 'POST',
                headers,
                body: JSON.stringify(CONFIG.testUser)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`ÁôªÂΩïÂ§±Ë¥•: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            if (!data.success || !data.data?.token) {
                throw new Error(`ÁôªÂΩïÂìçÂ∫îÊó†Êïà: ${JSON.stringify(data)}`);
            }

            this.authToken = data.data.token;
            return {
                token: this.authToken.substring(0, 20) + '...',
                user: data.data.user
            };
        }, 'apis');
    }

    // ===== Êï∞ÊçÆÂ∫ìÁªìÊûÑÈ™åËØÅ =====
    async testDatabaseStructure() {
        await this.log('ÂºÄÂßãÊï∞ÊçÆÂ∫ìÁªìÊûÑÈ™åËØÅ...', 'db');
        
        await this.test('Êï∞ÊçÆÂ∫ìËøûÊé•ÊµãËØï', async () => {
            try {
                const result = execSync(
                    `psql -h ${CONFIG.database.host} -p ${CONFIG.database.port} -U ${CONFIG.database.user} -d ${CONFIG.database.database} -c "SELECT version();"`,
                    { encoding: 'utf8', timeout: 10000 }
                );
                return { connected: true, version: result.trim() };
            } catch (error) {
                throw new Error(`Êï∞ÊçÆÂ∫ìËøûÊé•Â§±Ë¥•: ${error.message}`);
            }
        }, 'database');

        await this.test('Êï∞ÊçÆÂ∫ìË°®ÁªìÊûÑÊ£ÄÊü•', async () => {
            try {
                const tablesQuery = `
                    SELECT table_name, table_type 
                    FROM information_schema.tables 
                    WHERE table_schema = 'public' 
                    ORDER BY table_name;
                `;
                
                const result = execSync(
                    `psql -h ${CONFIG.database.host} -p ${CONFIG.database.port} -U ${CONFIG.database.user} -d ${CONFIG.database.database} -t -c "${tablesQuery}"`,
                    { encoding: 'utf8', timeout: 10000 }
                );
                
                const tables = result.trim().split('\n')
                    .filter(line => line.trim())
                    .map(line => {
                        const [name, type] = line.trim().split('|').map(s => s.trim());
                        return { name, type };
                    });
                
                return { 
                    tableCount: tables.length,
                    tables: tables
                };
            } catch (error) {
                throw new Error(`Ë°®ÁªìÊûÑÊü•ËØ¢Â§±Ë¥•: ${error.message}`);
            }
        }, 'database');

        // Ê£ÄÊü•ÂÖ≥ÈîÆË°®Â≠òÂú®ÊÄß
        const criticalTables = [
            'users', 'letters', 'letter_codes', 'couriers', 'tasks', 
            'products', 'orders', 'signal_codes', 'ai_configs', 'museum_items'
        ];

        for (const tableName of criticalTables) {
            await this.test(`Ë°® ${tableName} Â≠òÂú®ÊÄßÊ£ÄÊü•`, async () => {
                try {
                    const query = `
                        SELECT column_name, data_type, is_nullable 
                        FROM information_schema.columns 
                        WHERE table_name = '${tableName}' AND table_schema = 'public'
                        ORDER BY ordinal_position;
                    `;
                    
                    const result = execSync(
                        `psql -h ${CONFIG.database.host} -p ${CONFIG.database.port} -U ${CONFIG.database.user} -d ${CONFIG.database.database} -t -c "${query}"`,
                        { encoding: 'utf8', timeout: 5000 }
                    );
                    
                    const columns = result.trim().split('\n')
                        .filter(line => line.trim())
                        .map(line => {
                            const [name, type, nullable] = line.trim().split('|').map(s => s.trim());
                            return { name, type, nullable };
                        });
                    
                    if (columns.length === 0) {
                        throw new Error(`Ë°® ${tableName} ‰∏çÂ≠òÂú®`);
                    }
                    
                    return {
                        exists: true,
                        columnCount: columns.length,
                        columns: columns
                    };
                } catch (error) {
                    throw new Error(`Ë°®Ê£ÄÊü•Â§±Ë¥•: ${error.message}`);
                }
            }, 'database');
        }
    }

    // ===== APIÁ´ØÁÇπÂäüËÉΩÊµãËØï =====
    async testAPIEndpoints() {
        await this.log('ÂºÄÂßãAPIÁ´ØÁÇπÂäüËÉΩÊµãËØï...', 'info');

        if (!this.authToken) {
            await this.log('ÈúÄË¶ÅÂÖàÁôªÂΩïËé∑ÂèñËÆ§ËØÅtoken', 'warning');
            return;
        }

        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.authToken}`
        };
        
        // Ê∑ªÂä†CSRFÁõ∏ÂÖ≥headersÂ¶ÇÊûúÂèØÁî®
        if (this.csrfToken) {
            headers['X-CSRF-Token'] = this.csrfToken;
        }
        if (this.csrfCookie) {
            headers['Cookie'] = `csrf-token=${this.csrfCookie}`;
        }

        // ÊµãËØïÁî®Êà∑API
        await this.test('Ëé∑ÂèñÁî®Êà∑‰ø°ÊÅØ', async () => {
            const response = await fetch(`${CONFIG.backends.main}/api/v1/auth/me`, {
                method: 'GET',
                headers
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            return { user: data.data || data };
        }, 'apis');

        // ÊµãËØï‰ø°‰ª∂API  
        await this.test('Ëé∑Âèñ‰ø°‰ª∂ÂàóË°®', async () => {
            const response = await fetch(`${CONFIG.backends.main}/api/v1/letters`, {
                method: 'GET',
                headers
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            return { 
                letters: data.data?.letters || data.letters || [],
                total: data.data?.total || data.total || 0
            };
        }, 'apis');

        // ÊµãËØïÂïÜÂìÅAPI
        await this.test('Ëé∑ÂèñÂïÜÂìÅÂàóË°®', async () => {
            const response = await fetch(`${CONFIG.backends.main}/api/v1/shop/products`, {
                method: 'GET',
                headers
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            return {
                products: data.data?.products || data.products || [],
                total: data.data?.total || data.total || 0
            };
        }, 'apis');

        // ÊµãËØïAI API
        await this.test('AIÁÅµÊÑüÁîüÊàê', async () => {
            const response = await fetch(`${CONFIG.backends.main}/api/v1/ai/inspiration`, {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    theme: 'Ê†°Âõ≠ÁîüÊ¥ª',
                    count: 2
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            return {
                inspirations: data.data?.inspirations || [],
                count: (data.data?.inspirations || []).length
            };
        }, 'apis');

        // ÊµãËØï‰ø°‰ΩøÊúçÂä°API
        if (CONFIG.backends.courierService) {
            await this.test('‰ø°‰ΩøÊúçÂä°ÂÅ•Â∫∑Ê£ÄÊü•', async () => {
                const response = await fetch(`${CONFIG.backends.courierService}/health`, {
                    method: 'GET'
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return { healthy: true, status: response.status };
            }, 'apis');

            await this.test('Ëé∑Âèñ‰ø°‰ΩøÂ±ÇÁ∫ßÈÖçÁΩÆ', async () => {
                const response = await fetch(`${CONFIG.backends.courierService}/api/courier/levels/config`, {
                    method: 'GET',
                    headers
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                return data;
            }, 'apis');
        }

        // ÊµãËØïÂÜô‰ø°ÊúçÂä°API
        if (CONFIG.backends.writeService) {
            await this.test('ÂÜô‰ø°ÊúçÂä°ÂÅ•Â∫∑Ê£ÄÊü•', async () => {
                const response = await fetch(`${CONFIG.backends.writeService}/health`, {
                    method: 'GET'
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return { healthy: true, status: response.status };
            }, 'apis');
        }
    }

    // ===== Êï∞ÊçÆ‰∏ÄËá¥ÊÄßÊ£ÄÊü• =====
    async testDataConsistency() {
        await this.log('ÂºÄÂßãÊï∞ÊçÆ‰∏ÄËá¥ÊÄßÊ£ÄÊü•...', 'db');

        // Ê£ÄÊü•Áî®Êà∑Êï∞ÊçÆ‰∏ÄËá¥ÊÄß
        await this.test('Áî®Êà∑Êï∞ÊçÆ‰∏ÄËá¥ÊÄß', async () => {
            try {
                const userCountQuery = "SELECT COUNT(*) as count FROM users;";
                const result = execSync(
                    `psql -h ${CONFIG.database.host} -p ${CONFIG.database.port} -U ${CONFIG.database.user} -d ${CONFIG.database.database} -t -c "${userCountQuery}"`,
                    { encoding: 'utf8', timeout: 5000 }
                );
                
                const userCount = parseInt(result.trim());
                
                // ÈÄöËøáAPIËé∑ÂèñÁî®Êà∑Êï∞ÈáèËøõË°åÂØπÊØî
                const apiResponse = await fetch(`${CONFIG.backends.main}/api/v1/admin/users`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${this.authToken}`
                    }
                });
                
                let apiUserCount = 0;
                if (apiResponse.ok) {
                    const apiData = await apiResponse.json();
                    apiUserCount = apiData.data?.total || apiData.total || 0;
                }
                
                return {
                    databaseCount: userCount,
                    apiCount: apiUserCount,
                    consistent: userCount >= 0 // Âü∫Êú¨‰∏ÄËá¥ÊÄßÊ£ÄÊü•
                };
            } catch (error) {
                throw new Error(`Áî®Êà∑Êï∞ÊçÆÊ£ÄÊü•Â§±Ë¥•: ${error.message}`);
            }
        }, 'database');

        // Ê£ÄÊü•‰ø°‰ª∂Êï∞ÊçÆ‰∏ÄËá¥ÊÄß
        await this.test('‰ø°‰ª∂Êï∞ÊçÆ‰∏ÄËá¥ÊÄß', async () => {
            try {
                const letterCountQuery = "SELECT COUNT(*) as count FROM letters;";
                const result = execSync(
                    `psql -h ${CONFIG.database.host} -p ${CONFIG.database.port} -U ${CONFIG.database.user} -d ${CONFIG.database.database} -t -c "${letterCountQuery}"`,
                    { encoding: 'utf8', timeout: 5000 }
                );
                
                const dbLetterCount = parseInt(result.trim());
                
                return {
                    databaseCount: dbLetterCount,
                    hasLetters: dbLetterCount > 0
                };
            } catch (error) {
                throw new Error(`‰ø°‰ª∂Êï∞ÊçÆÊ£ÄÊü•Â§±Ë¥•: ${error.message}`);
            }
        }, 'database');

        // Ê£ÄÊü•ÂïÜÂìÅÊï∞ÊçÆ‰∏ÄËá¥ÊÄß
        await this.test('ÂïÜÂìÅÊï∞ÊçÆ‰∏ÄËá¥ÊÄß', async () => {
            try {
                const productCountQuery = "SELECT COUNT(*) as count FROM products;";
                const result = execSync(
                    `psql -h ${CONFIG.database.host} -p ${CONFIG.database.port} -U ${CONFIG.database.user} -d ${CONFIG.database.database} -t -c "${productCountQuery}"`,
                    { encoding: 'utf8', timeout: 5000 }
                );
                
                const dbProductCount = parseInt(result.trim());
                
                return {
                    databaseCount: dbProductCount,
                    hasProducts: dbProductCount > 0
                };
            } catch (error) {
                throw new Error(`ÂïÜÂìÅÊï∞ÊçÆÊ£ÄÊü•Â§±Ë¥•: ${error.message}`);
            }
        }, 'database');
    }

    // ===== Ë∑®ÊúçÂä°ÈõÜÊàêÊµãËØï =====
    async testCrossServiceIntegration() {
        await this.log('ÂºÄÂßãË∑®ÊúçÂä°ÈõÜÊàêÊµãËØï...', 'info');

        if (!this.authToken) {
            await this.log('Ë∑≥ËøáÈõÜÊàêÊµãËØïÔºöÈúÄË¶ÅËÆ§ËØÅtoken', 'warning');
            return;
        }

        // ÊµãËØïÂâçÁ´ØÂà∞ÂêéÁ´ØÁöÑÂÆåÊï¥Ë∞ÉÁî®Èìæ
        await this.test('ÂâçÁ´ØAPI‰ª£ÁêÜÈõÜÊàê', async () => {
            const response = await fetch(`${CONFIG.frontend}/api/ai/personas`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${this.authToken}`
                }
            });

            if (!response.ok) {
                throw new Error(`ÂâçÁ´ØAPI‰ª£ÁêÜÂ§±Ë¥•: ${response.status}`);
            }

            const data = await response.json();
            return {
                proxyWorking: true,
                personas: data.data?.personas || data.personas || []
            };
        }, 'integration');

        // ÊµãËØïÊï∞ÊçÆÂàõÂª∫Âà∞Êü•ËØ¢ÁöÑÂÆåÊï¥ÊµÅÁ®ã
        await this.test('Êï∞ÊçÆCRUDÂÆåÊï¥ÊµÅÁ®ã', async () => {
            const headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.authToken}`
            };

            // 1. ÂàõÂª∫ÊµãËØïÊï∞ÊçÆ (Ë¥≠Áâ©ËΩ¶)
            const addToCartResponse = await fetch(`${CONFIG.backends.main}/api/v1/shop/cart/items`, {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    product_id: 'test-product-1',
                    quantity: 1
                })
            });

            // 2. Êü•ËØ¢Ë¥≠Áâ©ËΩ¶
            const getCartResponse = await fetch(`${CONFIG.backends.main}/api/v1/shop/cart`, {
                method: 'GET',
                headers
            });

            return {
                addToCart: addToCartResponse.status,
                getCart: getCartResponse.status,
                crudFlow: addToCartResponse.status < 400 && getCartResponse.status < 400
            };
        }, 'integration');
    }

    // ===== ÊÄßËÉΩÂü∫ÂáÜÊµãËØï =====
    async testPerformance() {
        await this.log('ÂºÄÂßãÊÄßËÉΩÂü∫ÂáÜÊµãËØï...', 'info');

        await this.test('APIÂìçÂ∫îÊó∂Èó¥ÊµãËØï', async () => {
            const endpoints = [
                { name: 'health', url: `${CONFIG.backends.main}/health` },
                { name: 'auth/me', url: `${CONFIG.backends.main}/api/v1/auth/me` },
                { name: 'letters', url: `${CONFIG.backends.main}/api/v1/letters` }
            ];

            const results = {};
            
            for (const endpoint of endpoints) {
                const startTime = Date.now();
                try {
                    const response = await fetch(endpoint.url, {
                        method: 'GET',
                        headers: this.authToken ? {
                            'Authorization': `Bearer ${this.authToken}`
                        } : {}
                    });
                    
                    const duration = Date.now() - startTime;
                    results[endpoint.name] = {
                        duration,
                        status: response.status,
                        success: response.ok
                    };
                } catch (error) {
                    results[endpoint.name] = {
                        duration: Date.now() - startTime,
                        error: error.message,
                        success: false
                    };
                }
            }

            return results;
        }, 'integration');
    }

    // ===== ‰∏ªÊµãËØïÊµÅÁ®ã =====
    async runAllTests() {
        await this.log('üöÄ ÂºÄÂßãOpenPenPal API‰∏éÊï∞ÊçÆÂ∫ìÂÆåÊï¥ÊÄßÊµãËØï', 'info');
        await this.log(`ÊµãËØïÁõÆÊ†á: ${Object.keys(CONFIG.backends).length} ‰∏™ÂêéÁ´ØÊúçÂä°`, 'info');

        try {
            // 1. ÊúçÂä°ÂÅ•Â∫∑Ê£ÄÊü•
            await this.testServiceHealth();

            // 2. ËÆ§ËØÅÊµãËØï
            await this.testAuthentication();

            // 3. Êï∞ÊçÆÂ∫ìÁªìÊûÑÈ™åËØÅ
            await this.testDatabaseStructure();

            // 4. APIÁ´ØÁÇπÊµãËØï
            await this.testAPIEndpoints();

            // 5. Êï∞ÊçÆ‰∏ÄËá¥ÊÄßÊ£ÄÊü•
            await this.testDataConsistency();

            // 6. Ë∑®ÊúçÂä°ÈõÜÊàêÊµãËØï
            await this.testCrossServiceIntegration();

            // 7. ÊÄßËÉΩÊµãËØï
            await this.testPerformance();

        } catch (error) {
            await this.log(`ÊµãËØïËøáÁ®ã‰∏≠ÂèëÁîü‰∏•ÈáçÈîôËØØ: ${error.message}`, 'error');
        }

        // ÁîüÊàêÊµãËØïÊä•Âëä
        await this.generateReport();
    }

    // ===== ÁîüÊàêÊµãËØïÊä•Âëä =====
    async generateReport() {
        const testDuration = Date.now() - this.testStartTime.getTime();
        
        await this.log('\nüìä ===== ÊµãËØïÊä•Âëä =====', 'info');

        // ÁªüËÆ°ÂêÑÁ±ªÂà´ÁöÑÊàêÂäüÁéá
        for (const [category, tests] of Object.entries(this.results)) {
            if (Object.keys(tests).length === 0) continue;
            
            const total = Object.keys(tests).length;
            const successful = Object.values(tests).filter(t => t.success).length;
            const successRate = ((successful / total) * 100).toFixed(1);
            
            await this.log(`\nüìà ${category.toUpperCase()} Á±ªÂà´:`, 'info');
            await this.log(`   ‚úÖ ÊàêÂäü: ${successful}/${total} (${successRate}%)`, successful === total ? 'success' : 'warning');
            
            // ÊòæÁ§∫Â§±Ë¥•ÁöÑÊµãËØï
            const failures = Object.entries(tests).filter(([_, test]) => !test.success);
            if (failures.length > 0) {
                await this.log(`   ‚ùå Â§±Ë¥•ÁöÑÊµãËØï:`, 'error');
                for (const [testName, test] of failures) {
                    await this.log(`      ‚Ä¢ ${testName}: ${test.error}`, 'error');
                }
            }
        }

        // ÊÄª‰ΩìÁªüËÆ°
        const allTests = Object.values(this.results).flatMap(category => Object.values(category));
        const totalTests = allTests.length;
        const totalSuccessful = allTests.filter(t => t.success).length;
        const overallSuccessRate = totalTests > 0 ? ((totalSuccessful / totalTests) * 100).toFixed(1) : 0;

        await this.log('\nüéØ ÊÄª‰ΩìÁªüËÆ°:', 'info');
        await this.log(`   üìä ÊÄªÊµãËØïÊï∞: ${totalTests}`, 'info');
        await this.log(`   ‚úÖ ÊàêÂäü: ${totalSuccessful}`, 'success');
        await this.log(`   ‚ùå Â§±Ë¥•: ${totalTests - totalSuccessful}`, totalSuccessful === totalTests ? 'info' : 'error');
        await this.log(`   üìà ÊàêÂäüÁéá: ${overallSuccessRate}%`, overallSuccessRate >= 80 ? 'success' : 'warning');
        await this.log(`   ‚è±Ô∏è  ÊÄªËÄóÊó∂: ${(testDuration / 1000).toFixed(2)}Áßí`, 'info');

        // ÂÖ≥ÈîÆÂèëÁé∞
        await this.log('\nüîç ÂÖ≥ÈîÆÂèëÁé∞:', 'info');
        
        const servicesStatus = this.results.services || {};
        const healthyServices = Object.values(servicesStatus).filter(s => s.success).length;
        const totalServices = Object.keys(servicesStatus).length;
        
        if (healthyServices === totalServices) {
            await this.log(`   ‚úÖ ÊâÄÊúâ ${totalServices} ‰∏™ÊúçÂä°ËøêË°åÊ≠£Â∏∏`, 'success');
        } else {
            await this.log(`   ‚ö†Ô∏è  ${healthyServices}/${totalServices} ‰∏™ÊúçÂä°Ê≠£Â∏∏ËøêË°å`, 'warning');
        }

        const dbTests = this.results.database || {};
        const dbSuccess = Object.values(dbTests).filter(t => t.success).length;
        if (dbSuccess > 0) {
            await this.log(`   ‚úÖ Êï∞ÊçÆÂ∫ìËøûÊé•ÂíåÁªìÊûÑÈ™åËØÅÈÄöËøá`, 'success');
        } else {
            await this.log(`   ‚ùå Êï∞ÊçÆÂ∫ìÊµãËØïÂ≠òÂú®ÈóÆÈ¢ò`, 'error');
        }

        const apiTests = this.results.apis || {};
        const apiSuccess = Object.values(apiTests).filter(t => t.success).length;
        if (apiSuccess > 0) {
            await this.log(`   ‚úÖ APIÁ´ØÁÇπÂäüËÉΩÊ≠£Â∏∏`, 'success');
        }

        await this.log('\n‚ú® ÊµãËØïÂÆåÊàêÔºÅ', 'success');
        
        // ‰øùÂ≠òËØ¶ÁªÜÊä•ÂëäÂà∞Êñá‰ª∂
        const reportData = {
            timestamp: new Date().toISOString(),
            duration: testDuration,
            summary: {
                total: totalTests,
                successful: totalSuccessful,
                failed: totalTests - totalSuccessful,
                successRate: overallSuccessRate
            },
            results: this.results,
            config: CONFIG
        };

        require('fs').writeFileSync(
            'api-database-integrity-report.json',
            JSON.stringify(reportData, null, 2)
        );
        
        await this.log('üìÑ ËØ¶ÁªÜÊä•ÂëäÂ∑≤‰øùÂ≠òÂà∞: api-database-integrity-report.json', 'info');
    }
}

// ÊâßË°åÊµãËØï
async function main() {
    const tester = new APIIntegrityTester();
    await tester.runAllTests();
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = APIIntegrityTester;